
## 1. 原题描述 (Problem Statement)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** `target` 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 1：**

> 输入： nums = [2,7,11,15], target = 9
>
> 输出： [0,1]
>
> 解释： 因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

**示例 2：**

> 输入： nums = [3,2,4], target = 6
>
> 输出： [1,2]

**示例 3：**

> 输入： nums = [3,3], target = 6
>
> 输出： [0,1]

---

## 2. 标准解析 (Standard Analysis)

这道题的核心在于如何快速找到目标组合。

* 暴力解法 (Brute Force)：
  使用两层循环。第一层循环遍历 x，第二层循环遍历 y，判断 x + y == target。
  * 缺点：时间复杂度为 **$O(n^2)$**，效率极低。如果数组有一万个数，计算机要算一亿次。
* 哈希表法 (Hash Map) —— 推荐解法：
  利用空间换时间的思想。
  我们遍历数组，对于每一个数 x，我们其实是在寻找是否存在一个 y，使得 y = target - x。
  如果我们能把遍历过的数都存起来，并且查找速度极快（$O(1)$），那么我们只需要遍历一次数组即可。
  * 数据结构选择：哈希表（Python 中的 `dict`）。

---

## 3. 通俗理解与逻辑可视化 (Visual Logic)

### 💡 通俗理解

想象你在玩“配对游戏”。

你拿着一个空的小本本（哈希表）从头走到尾。

每看到一个数字，你先算一下：“我要找的另一半是多少？”

然后看一眼小本本：“我之前见过这个另一半吗？”

* 如果见过：Bingo！找到了，游戏结束。
* 如果没见过：把你现在的数字和位置记在小本本上，继续往下走，方便后面的人来找你。

### 🎨 逻辑可视化 (ASCII 动画)

假设 `nums = [2, 11, 7, 15]`, `target = 9`

```
[ 初始状态 ]
小本本 (Dict): {}  <-- 空的

----------------------------------------

[ 循环 1 ]  i = 0
当前数字: 2
我要找谁: 9 - 2 = 7
👀 回头看小本本: 有 7 吗？ -> ❌ (本子是空的)
📝 动作: 把自己记下来 (等你来找我)
小本本: { 2: 0 } 

----------------------------------------

[ 循环 2 ]  i = 1
当前数字: 11
我要找谁: 9 - 11 = -2
👀 回头看小本本: 有 -2 吗？ -> ❌ (只有 2)
📝 动作: 把自己记下来
小本本: { 2: 0, 11: 1 }

----------------------------------------

[ 循环 3 ]  i = 2
当前数字: 7
我要找谁: 9 - 7 = 2
👀 回头看小本本: 有 2 吗？ -> ✅ 有！(在下标 0)
🎉 动作: 配对成功！
返回结果: [0, 2]  (之前那个数的下标, 当前下标)
```

## 4. Solution.py (Pythonic 代码)

这是可以直接运行的标准答案，我加上了保姆级注释。

**Python**

```
from typing import List

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        """
        :param nums: List[int] - 输入的整数数组
        :param target: int - 目标和
        :return: List[int] - 两个数的下标
        """
      
        # 创建一个哈希表（字典）用于存储 {数值: 下标}
        # 作用：充当“记忆小本本”，让我们能以 O(1) 时间查到之前遍历过的数
        prev_map = {} 
      
        # enumerate 是 Python 的神器，它能同时给你 下标(i) 和 数值(num)
        # 这样比写 for i in range(len(nums)) 优雅得多
        for i, num in enumerate(nums):
          
            # 1. 计算我们渴望找到的“另一半”
            diff = target - num
          
            # 2. 查表：看看这一半是不是已经在前面出现过了
            if diff in prev_map:
                # 3. 如果找到了，直接返回 [之前的下标, 当前下标]
                return [prev_map[diff], i]
          
            # 4. 如果没找到，把自己登记进表里，等待未来的数字来匹配
            prev_map[num] = i
          
        # 题目保证一定有解，所以理论上代码不会走到这里
        return []
```

---

## 5. 面试官视角深度剖析 (Deep Dive)

### ⏱️ 复杂度分析

这是面试必问环节，必须张口就来。

* **时间复杂度：**$O(N)$
  * **解释** ：我们只遍历了一次数组（**$N$** 个元素）。在循环内部，Python 字典的查找 (`if diff in prev_map`) 和插入 (`prev_map[num] = i`) 操作，平均时间复杂度是 **$O(1)$** 的。
  * 所以总耗时 = **$N \times 1 = O(N)$**。
* **空间复杂度：**$O(N)$
  * **解释** ：在最坏的情况下（比如目标是两个非常大的数，或者这两个数在数组的最后两个位置），我们需要把前面的 **$N-1$** 个元素都存进字典里。哈希表占用的空间与元素数量成正比。

### ⚠️ 避坑指南 (易错点)

1. **不要把所有数先存进字典** ：

* **错误写法** ：先写一个 `for` 把所有数存进 `dict`，再写一个 `for` 去查找。
* **为什么错** ：如果数组是 `[3, 3]`，`target = 6`。
  * 第一遍存的时候，第二个 `3` 会覆盖第一个 `3`（字典 Key 唯一）。
  * 第二遍找的时候，`3` 找 `3`，会找到它自己（或者找不到被覆盖的那个），导致逻辑错误。
* **正确做法** ： **边遍历，边查找** （One-pass Hash Table）。这样在查的时候，自己肯定还没存进去，查到的一定是**之前**的数，绝对不会查到自己。

1. **返回值顺序** ：

* 虽然题目说“任意顺序”，但习惯上我们返回 `[较小索引, 较大索引]`。我们的代码 `return [prev_map[diff], i]` 天然满足这个要求，因为 `prev_map[diff]` 肯定是之前存进去的，`i` 是现在的，所以 `prev_map[diff] < i`。

### 🚀 进阶追问

面试官可能会问：

> “如果数组已经排好序了（Sorted Array），你还能优化吗？”

* **回答** ：如果有序，我们就不需要哈希表了（可以省去 **$O(N)$** 的空间）。
* **解法** ：使用  **双指针 (Two Pointers)** 。一个指针在头，一个在尾。
* 如果 `和 > target`，尾指针左移（让和变小）。
* 如果 `和 < target`，头指针右移（让和变大）。
* *(这是 LeetCode 167 题的内容)*
