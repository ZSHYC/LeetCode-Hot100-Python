
# 560. 和为 K 的子数组 (Subarray Sum Equals K)

## 1. 原题描述 (Problem Statement)

给你一个整数数组 `nums` 和一个整数 `k`，请你统计数组中 **和为 k** 的连续子数组的个数。

**示例 1：**

> 输入： nums = [1, 1, 1], k = 2
>
> 输出： 2
>
> 解释： [1, 1] (前两个) 和 [1, 1] (后两个) 加起来都是 2。

**示例 2：**

> 输入： nums = [1, 2, 3], k = 3
>
> 输出： 2
>
> 解释： [1, 2] 和 [3]。

**示例 3 (重要)：**

> 输入： nums = [1, -1, 0], k = 0
>
> 输出： 3
>
> 解释： [1, -1], [0], [1, -1, 0]。
>
> 注意：数组里可能有负数！这意味着子数组越长，和不一定越大。

---

## 2. 标准解析 (Standard Analysis)

我们需要找一段连续的子数组 `nums[i..j]`，使得它的和等于 `k`。

* **解法一：暴力枚举 (Brute Force)**
  * 思路：用两个循环确定起点 `i` 和终点 `j`，算它们中间的和。
  * 时间复杂度：**$O(N^2)$**。
  * **结果** ：在 LeetCode 上会直接超时 (Time Limit Exceeded)。面试写这个就挂了。
* **解法二：滑动窗口 (Sliding Window) —— ❌ 陷阱！**
  * 很多人看到“连续子数组”就想滑窗。但滑窗的前提是**“单调性”**（比如全是正数，窗变大和就变大）。
  * 这道题有 **负数** ！加一个负数，和反而变小了。滑窗法则失效。
* **解法三：前缀和 + 哈希表 (Prefix Sum + Hash Map) —— ✅ 推荐**
  * 核心公式：

    $$
    子数组和 = \text{当前前缀和} - \text{历史前缀和}
    $$

    $$
    k = \text{current\_sum} - \text{old\_sum}
    $$
  * 移项变形（变成两数之和的形式）：

    $$
    \text{old\_sum} = \text{current\_sum} - k
    $$
  * **策略** ：
  * 我走到当前位置，算出从头到现在的总和 `current_sum`。
  * 我回头问哈希表：“嘿，我不记得具体的路了，但你记录里有没有出现过和为 `current_sum - k` 的历史时刻？”
  * 如果有，说明从那个“历史时刻”到“现在”这一段路，和刚好是 `k`。

---

## 3. 通俗理解与逻辑可视化 (Visual Logic)

### 生活比喻：查账单

你是一个剁手党，想知道你的消费记录里，有几次**“连续几笔消费总额刚好是 100 元”**。

你没法单独记每一笔，但你手里有一张 **总账单（前缀和）** ，记录着“从开始到现在一共花了多少钱”。

* **目标 k = 100** 。
* **Step 1** ：周一总花费 50。
* 回头看：以前有过“总花费 = 50 - 100 = -50”的时候吗？没。
* **Step 2** ：周二又花了 100， **总花费 150** 。
* 回头看：以前有过“总花费 = 150 - 100 =  **50** ”的时候吗？
* 查账本：**有！** (周一就是 50)。
* **推论** ：那说明从“周一之后”到“周二”这期间，刚好花了 100。

### ASCII 动画演示

**Plaintext**

```
输入数组: [1, 2, 3], k = 3
哈希表 (记录前缀和出现的次数): {0: 1} 
★ 初始放入 {0:1} 代表“还没开始走的时候，和为0，出现1次”

[ Step 1 ] 遇到数字: 1
   当前前缀和 (curr): 1
   我想找的历史 (need): 1 - 3 = -2
   查表: 有 -2 吗？❌
   存入当前和: {0: 1, 1: 1}

[ Step 2 ] 遇到数字: 2
   当前前缀和 (curr): 1 + 2 = 3
   我想找的历史 (need): 3 - 3 = 0
   查表: 有 0 吗？✅ (有1次)
   -> 找到一个答案! (对应子数组 [1, 2])
   存入当前和: {0: 1, 1: 1, 3: 1}

[ Step 3 ] 遇到数字: 3
   当前前缀和 (curr): 3 + 3 = 6
   我想找的历史 (need): 6 - 3 = 3
   查表: 有 3 吗？✅ (有1次)
   -> 找到一个答案! (对应子数组 [3])
   存入当前和: {..., 6: 1}

最终结果: 2
```

---

## 4. Solution.py (Pythonic 代码)

**Python**

```
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        # 1. 初始化哈希表
        # Key: 前缀和, Value: 这个前缀和出现的次数
        # 必须预设 {0: 1}，用来处理“从头开始累加刚好等于k”的情况
        prefix_map = {0: 1}
      
        curr_sum = 0
        count = 0
      
        # 2. 遍历数组
        for num in nums:
            curr_sum += num  # 计算当前前缀和
          
            # 3. 核心公式：寻找满足 (curr_sum - old_sum = k) 的 old_sum
            target = curr_sum - k
          
            # 如果历史记录里有这个 target，说明中间有一段和为 k
            if target in prefix_map:
                count += prefix_map[target]
          
            # 4. 把当前的前缀和记录下来
            # 相当于在账本上写一笔：总金额 curr_sum 又出现了一次
            prefix_map[curr_sum] = prefix_map.get(curr_sum, 0) + 1
          
        return count
```

---

## 5. 面试官视角深度剖析 (Deep Dive)

* **难点解析：为什么要初始化 `{0: 1}`？**
  * 假设 `nums = [3]`, `k = 3`。
  * 遍历第一个数，`curr_sum = 3`。
  * 我们想找 `target = 3 - 3 = 0`。
  * 如果哈希表里是空的，我们就找不到 `0`，结果返回 0，这显然错了。
  * **含义** ：`{0: 1}` 代表**“数组开始之前，和为 0 的情况出现过 1 次”**。这让我们可以算出从索引 0 开始的子数组。
* **复杂度分析** ：
* **时间复杂度** ：**$O(N)$**。就像“两数之和”一样，我们只扫了一遍数组，查表是 **$O(1)$**。
* **空间复杂度** ：**$O(N)$**。最坏情况下（比如全是正数），前缀和都不一样，哈希表要存 N 个不同的 Key。
* **避坑指南** ：
* **不要用列表切片** ：千万别写 `sum(nums[i:j])` 这种代码，切片求和是 **$O(N)$**，套在循环里就变 **$O(N^2)$** 了。
* **返回值是次数** ：题目问的是“个数”，不是“子数组本身”。如果问子数组本身，哈希表就要存 `{前缀和: [索引列表]}`，会麻烦很多。
* **进阶思维 (Follow-up)** ：
* *问：如果题目要求在这个数组里找“最长的”和为 K 的子数组长度，怎么改？*
* *答* ：哈希表的 Value 不存次数，改存**“第一次出现该前缀和的下标”**。计算长度时用 `current_index - old_index`。

这道题是哈希表应用的分水岭。能熟练运用 `prefix_map[curr - k]` 这个公式，说明你已经脱离了“数数”的初级阶段，开始掌握**空间换时间**的高级逻辑了！
