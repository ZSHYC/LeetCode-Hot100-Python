
# 169. 多数元素 (Majority Element) —— 哈希表版

## 1. 原题描述 (Problem Statement)

给定一个大小为 n 的数组 nums，返回其中的 多数元素。

多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1：**

> 输入： nums = [3, 2, 3]
>
> 输出： 3
>
> 解释： 3 出现了 2 次，总数是 3，2 > 1.5，符合。

**示例 2：**

> 输入： nums = [2, 2, 1, 1, 1, 2, 2]
>
> 输出： 2
>
> 解释： 2 出现了 4 次，总数是 7，4 > 3.5，符合。

---

## 2. 标准解析 (Standard Analysis)

### 为什么选哈希表？

我们要解决的核心问题是： **“统计每个候选人的票数”** 。

* **暴力法** ：拿出一个数字，去数组里数它出现了几次。再拿下一个... 时间复杂度是 **$O(N^2)$**，就像你去数一堆乱序的选票，拿一张看一眼，放下再拿下一张，效率极低。
* **哈希表法** ：准备一个 **记分板** （字典）。遍历选票，读到一个名字，就在对应的名字后面画“正”字。只需遍历一次。

### 核心策略

1. 创建一个空字典（哈希表）用于计数。
2. 计算出获胜标准：`target = n // 2`。
3. 遍历数组，把数字存入字典计数。
4. **边存边查** ：每次加完分，立刻看一眼它现在的票数是不是超过了 `target`。如果超过，直接宣布获胜（返回结果），不用等数完。

---

## 3. 通俗理解与逻辑可视化 (Visual Logic)

### 生活比喻：班长选举唱票

想象你在教室黑板前唱票。

* 你的手里（内存）拿着一叠乱序的选票 `[2, 2, 1, 1, 1, 2, 2]`。
* 黑板（哈希表）上记录每个人的票数。
* 全班 7 个人，谁先拿到 4 票，谁就是班长，立刻停止唱票。

### ASCII 动画演示

**Plaintext**

```
输入数组: [2, 2, 1, 1, 1, 2, 2]
总长度 n = 7
获胜目标: > 3 (即至少 4 票)

哈希表(记分板): {}

[ Step 1 ] 读取: 2
   操作: 记分板上没有 2，写上去，票数计 1
   状态: {2: 1}
   检查: 1 > 3? ❌ 继续

[ Step 2 ] 读取: 2
   操作: 2 的票数 + 1
   状态: {2: 2}
   检查: 2 > 3? ❌ 继续

[ Step 3 ] 读取: 1
   操作: 记分板上没有 1，写上去，票数计 1
   状态: {2: 2, 1: 1}
   检查: 1 > 3? ❌ 继续

[ ...省略中间步骤... ]

[ Step 6 ] 读取: 2
   操作: 2 的票数 + 1
   状态: {2: 4, 1: 3}
   检查: 4 > 3? ✅ 找到了！
   
   👉 直接返回结果 2，后面的票不用数了。
```

---

## 4. Solution.py (Pythonic 代码)

**Python**

```
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        # 1. 准备一个哈希表 (字典)
        counts = {}
      
        # 2. 计算出“多数”的门槛 (向下取整)
        target = len(nums) // 2
      
        # 3. 遍历每个数字
        for num in nums:
            # 技巧：counts.get(num, 0) 
            # 意思是：尝试获取 num 的值，如果 num 不在字典里，就默认返回 0
            counts[num] = counts.get(num, 0) + 1
          
            # 4. 剪枝：一旦发现当前数字超过一半，立刻返回
            # 这样不用等遍历完整个数组
            if counts[num] > target:
                return num
              
        return 0 # 理论上不会走到这，因为题目保证存在多数元素
```

---

## 5. 面试官视角深度剖析 (Deep Dive)

### 复杂度分析

* **时间复杂度** ：**$O(N)$**
* **大白话** ：我们只把数组从头到尾看了一遍。哈希表的插入和查询操作平均是 **$O(1)$** 的，所以总耗时跟数据量成正比。
* **空间复杂度** ：**$O(N)$**
* **大白话** ：我们需要一个字典来存不同的数字。最坏的情况下（比如数组是 `[1, 2, 3, 4, 5, ...]`），我们需要存 **$N/2$** 个不同的数字（虽然题目说有众数，但哈希表本身需要开辟内存）。

### 避坑指南

1. **整数除法** ：Python 里 `n / 2` 得到的是浮点数（如 `3.5`），`n // 2` 才是整数（如 `3`）。虽然比较的时候浮点数也没问题，但在算法题里习惯用整数。
2. **字典的 Key** ：回忆我们之前讲的，数组 `[1, 2]` 是不能做 Key 的。但这道题输入是整数，整数是不可变的，所以完全没问题。
3. **直接调库** ：面试时可以提一句  *“我可以用 `collections.Counter(nums).most_common(1)[0][0]` 一行搞定，但我还是手写一下逻辑展示细节”* 。这样既显得你懂 Python 标准库，又显得你基础扎实。
