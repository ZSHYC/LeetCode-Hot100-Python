摩尔投票法（Boyer-Moore Voting Algorithm）是这道题的 **巅峰解法** ，也是面试官最想看到的答案，因为它把空间从 **$O(N)$** 压缩到了极致的  **$O(1)$** 。

下面我们严格按照【五步走】带你彻底搞懂这个“极限一换一”的算法。

---

# 169. 多数元素 (Majority Element) —— 摩尔投票法版

## 1. 原题描述 (Problem Statement)

给定一个大小为 n 的数组 nums，返回其中的 多数元素。

多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1：**

> 输入： nums = [3, 2, 3]
>
> 输出： 3

**示例 2：**

> 输入： nums = [2, 2, 1, 1, 1, 2, 2]
>
> 输出： 2

---

## 2. 标准解析 (Standard Analysis)

### 为什么暴力法和哈希表不够完美？

* **哈希表** ：虽然快，但需要存所有不一样的数字。如果 `N` 是 10 亿，你内存可能就爆了。
* **排序法** ：虽然不需要额外空间，但排序本身很慢 (**$O(N \log N)$**)。

### 摩尔投票法的核心思想

这是一个**“消消乐”**的游戏。

* 核心原理： **极限一换一** 。
* 既然多数元素的数量 > 总数的一半，那么：
  * 让多数元素（比如“魏国”）和其他所有杂牌军（“蜀国”、“吴国”...）打架。
  * 每次遇到一个“非自己人”，就同归于尽（两个都死）。
  * **结局** ：因为“魏国”兵多，哪怕跟所有敌人同归于尽，最后战场上活下来的，**一定**还是魏国人。

---

## 3. 通俗理解与逻辑可视化 (Visual Logic)

### 生活比喻：擂台争霸赛

我们要维护两个变量：

1. **擂主 (`candidate`)** ：当前站在台上的人。
2. **血量 (`count`)** ：擂主还剩几条命。

 **规则** ：

1. **空擂台** ：如果没有擂主（`count=0`），谁上来谁就是擂主，血量=1。
2. **自己人** ：如果上来的挑战者跟擂主是一伙的，擂主血量 +1。
3. **敌人** ：如果上来的挑战者跟擂主不是一伙的，两人打一架，同归于尽（擂主血量 -1）。

### ASCII 动画演示

数组：`[2, 2, 1, 1, 1, 2, 2]`

**Plaintext**

```
初始状态: 擂主=None, 血量=0

[ Step 1 ] 遇到士兵: 2
   擂台是空的(血量0) -> 2 登基
   状态: 擂主=2, 血量=1

[ Step 2 ] 遇到士兵: 2
   是友军(2==2) -> 加血
   状态: 擂主=2, 血量=2

[ Step 3 ] 遇到士兵: 1
   是敌人(1!=2) -> 开打(一换一)
   状态: 擂主=2, 血量=1 (2 还在，但受了伤)

[ Step 4 ] 遇到士兵: 1
   是敌人(1!=2) -> 开打(一换一)
   状态: 擂主=2, 血量=0 (2 倒下了，擂台空了！)

[ Step 5 ] 遇到士兵: 1
   擂台是空的 -> 1 趁虚而入登基
   状态: 擂主=1, 血量=1

[ Step 6 ] 遇到士兵: 2
   是敌人(2!=1) -> 开打
   状态: 擂主=1, 血量=0 (1 倒下了，擂台又空了)

[ Step 7 ] 遇到士兵: 2
   擂台是空的 -> 2 重新登基
   状态: 擂主=2, 血量=1

[ 结束 ] 战场上最后站着的是: 2 ✅
```

---

## 4. Solution.py (Pythonic 代码)

**Python**

```
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        # 初始化两个核心变量
        candidate = None  # 当前霸主
        count = 0         # 霸主血量
    
        for num in nums:
            # 1. 如果当前血量为 0，说明之前的霸主死光了
            # 或者是刚开始，当前这个数直接上位
            if count == 0:
                candidate = num
        
            # 2. 判断是敌是友
            if num == candidate:
                # 友军：血量加一
                count += 1
            else:
                # 敌人：同归于尽 (血量减一)
                count -= 1
            
        # 题目保证多数元素一定存在，所以最后剩下的 candidate 一定是它
        return candidate
```

---

## 5. 面试官视角深度剖析 (Deep Dive)

### 复杂度分析

* **时间复杂度** ： **$O(N)$** 。我们只遍历了一次数组，每个动作（比较、加减）都是常数时间。
* **空间复杂度** ： **$O(1)$** 。**这是亮点！** 不管数组有 100 万还是 1 亿个数据，我们始终只用了 `candidate` 和 `count` 两个变量。这在大数据场景下价值连城。

### 避坑指南

1. **逻辑顺序** ：代码里一定要 **先判断 `count == 0`** ，再进行加减分。

* *错误写法* ：先减分，减完发现是 0 再换人。这会导致逻辑混乱（刚换的人马上被减分）。
* *正确逻辑* ：你倒下了（count=0），下一轮新兵来的时候，直接由新兵接管擂台。

1. **多数元素不存在的情况** ：

* 本题保证存在，所以直接返回 `candidate`。
* *进阶坑* ：如果题目说“可能不存在”，那么最后算出 `candidate` 后，必须 **再遍历一次数组** ，统计它的真实出现次数，确认是否真的 **$> n/2$**。
