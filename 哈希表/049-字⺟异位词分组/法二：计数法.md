
# 49. 字母异位词分组 (进阶：计数法版)

## 1. 核心思路：从“照片”到“指纹”

* **排序法 (之前的做法)** ：
* 就像给全班同学排队。不管你是 `eat` 还是 `tea`，排好队后都是 `aet`。
* **缺点** ：排队（排序）是很慢的！如果单词特别长（比如 DNA 序列），排一次队要很久。
* **计数法 (优化做法)** ：
* 我们不排队了，直接扫描！
* 就像超市结账扫描 **条形码** 。
* 不管你 `a` 在哪，`t` 在哪，我只关心：
  * 你有几个 `a`？(1个)
  * 你有几个 `b`？(0个)
  * ...
  * 你有几个 `z`？(0个)
* 生成的这个**“26位数字条形码”**就是你的身份证。

---

## 2. 逻辑可视化 (Visual Logic)

我们用一个长度为 26 的数组来代表 a-z 的数量。

假设输入单词：`"eat"`

**Plaintext**

```
[ Step 1 ] 初始化空数组 (对应 a-z)
count = [0, 0, 0, 0, ..., 0]  (共26个0)

[ Step 2 ] 扫描字符 'e'
   'e' 是第 5 个字母 -> count[4] 加 1
   count = [0, 0, 0, 0, 1, ..., 0]
                        ^

[ Step 3 ] 扫描字符 'a'
   'a' 是第 1 个字母 -> count[0] 加 1
   count = [1, 0, 0, 0, 1, ..., 0]
            ^

[ Step 4 ] 扫描字符 't'
   't' 是第 20 个字母 -> count[19] 加 1
   count = [1, 0, 0, ..., 1, ..., 0]
                          ^

[ Step 5 ] 生成身份证 (Key)
   因为列表不能当 Key，要把它变成元组 (Tuple)
   Key = (1, 0, 0, 0, 1, ..., 1, ...) 
   这就是 "eat" 的唯一条形码。
```

同理，`"tea"` 也会生成一模一样的 `(1, 0, 0, 0, 1, ...)`，所以它们会被扔进同一个桶里。

---

## 3. Solution.py (Pythonic 代码)

**Python**

```
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        from collections import defaultdict
      
        # 依然使用哈希表
        anagram_map = defaultdict(list)
      
        for s in strs:
            # 1. 创建一个长度为 26 的全 0 列表
            #    [0, 0, ..., 0]
            count = [0] * 26
          
            # 2. 统计每个字符出现的次数
            for char in s:
                # ord(char) 获取字符的 ASCII 数值
                # ord('a') 是 97。
                # 比如 char 是 'b'，ord('b')-ord('a') = 98-97 = 1 (索引位置)
                index = ord(char) - ord('a')
                count[index] += 1
          
            # 3. 把列表转成元组 (tuple)，才能作为字典的 Key
            #    注意：Python 字典的 Key 必须是不可变的，List 可变，Tuple 不可变
            key = tuple(count)
          
            # 4. 归类
            anagram_map[key].append(s)
          
        return list(anagram_map.values())
```

---

## 4. 面试官视角深度剖析

### 🧐 为什么这个更快？(复杂度对比)

* **排序法** ：**$O(N \cdot K \log K)$**
* 瓶颈在 `sorted(s)`。如果 **$K=1000$**，**$\log K \approx 10$**，要运算 **$1000 \times 10 = 10000$** 次。
* **计数法** ：**$O(N \cdot K)$**
* 瓶颈在遍历字符串 `for char in s`。如果 **$K=1000$**，就只运算 **$1000$** 次。
* **省掉了那个 **$\log K$** 的乘数！**

### ⚠️ 新手避坑指南

1. **`ord()` 是什么？**
   * 这是 Python 的内置函数，用来把字母转成数字编号。
   * `ord('a')` 是 97。这也是为什么我们要减去 `ord('a')`，是为了让 `a` 对应索引 `0`，`b` 对应索引 `1`。
2. **为什么要 `tuple(count)`？**
   * 尝试写 `map[[1,0...]] = ...` 会直接报错 `TypeError: unhashable type: 'list'`。
   * **记住铁律** ：Python 字典的 Key 必须是“死”的（不可变），不能是“活”的（可变列表）。

### 🎯 什么时候用计数法？

* 如果面试官说：“字符串只包含小写字母 `a-z`”， **首选计数法** 。
* 如果面试官说：“字符串包含所有 Unicode 字符（中文、Emoji 等）”，那 `count` 数组要开很大很大，这时候**排序法**反而更好（更通用）。
