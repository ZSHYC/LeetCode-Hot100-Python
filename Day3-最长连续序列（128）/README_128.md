
# 128. 最长连续序列 (Longest Consecutive Sequence)

## 1. 原题描述 (Problem Statement)

给定一个未排序的整数数组 `nums`，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

**请你设计并实现时间复杂度为 **$O(n)$** 的算法解决此问题。**

**示例 1：**

> 输入： nums = [100, 4, 200, 1, 3, 2]
>
> 输出： 4
>
> 解释： 最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

**示例 2：**

> 输入： nums = [0, 3, 7, 2, 5, 8, 4, 6, 0, 1]
>
> 输出： 9
>
> 解释： 最长数字连续序列是 [0, 1, 2, 3, 4, 5, 6, 7, 8]。

---

## 2. 标准解析 (Standard Analysis)

我们需要在杂乱无章的数组中找到连续的数字（如 1, 2, 3...）。

* **解法一：排序法 (Sorting)** 最直观的想法是先将数组排序，然后遍历一遍统计最长连续子段。
  * **缺点** ：排序的时间复杂度最快也是 **$O(n \log n)$**，不符合题目 **$O(n)$** 的严格要求。
* **解法二：哈希集合法 (Hash Set) —— 推荐** 利用哈希表（Set）查找时间复杂度为 **$O(1)$** 的特性。
  1. 先把所有数字丢进 `set` 去重。
  2. 遍历 `set` 中的每个数 `x`。
  3. **关键判断** ：只有当 `x-1` **不在** `set` 中时，才说明 `x` 是一个连续序列的 **起点** （例如 `[1, 2, 3]` 中，我们只从 `1` 开始数，遇到 `2` 或 `3` 直接跳过）。
  4. 从起点开始不断查询 `x+1`, `x+2`... 是否存在，统计长度。

---

## 3. 通俗理解与逻辑可视化 (Visual Logic)

### 生活比喻：扑克牌理牌

想象桌上扔了一堆杂乱的扑克牌：[100, 4, 200, 1, 3, 2]。

你要找出最长的顺子。

1. **第一步（去重）** ：先把重复的牌扔掉，把剩下的牌摊在桌上（存入 Set），方便一眼看到有没有某张牌。
2. **第二步（找龙头）** ：你随手拿起一张牌，比如  **3** 。

* 你会先看一眼：有没有  **2** ？如果有，那你不会从 **3** 开始数顺子，因为 **3** 肯定跟在 **2** 后面。你把 **3** 放下。
* 你拿起  **1** 。看一眼：有没有  **0** ？没有！**哈！1 就是个龙头！**

1. **第三步（数顺子）** ：

* 从 **1** 开始，找  **2** （有），找  **3** （有），找  **4** （有），找  **5** （没）。
* 顺子长度 = 4。

### ASCII 动画演示

```
原始数组: [100, 4, 200, 1, 3, 2]
哈希集合: {1, 2, 3, 4, 100, 200}

[ 遍历过程 ]

1. 当前数: 100
   检查: 99 在集合吗? ❌ (NO) -> 它是起点!
   开始数: 100 -> 101(❌)
   长度: 1

2. 当前数: 4
   检查: 3 在集合吗? ✅ (YES) -> 它不是起点，跳过! (省力气)

3. 当前数: 200
   检查: 199 在集合吗? ❌ (NO) -> 它是起点!
   开始数: 200 -> 201(❌)
   长度: 1

4. 当前数: 1
   检查: 0 在集合吗? ❌ (NO) -> 它是起点!
   开始数: 1 -> 2(✅) -> 3(✅) -> 4(✅) -> 5(❌)
   长度: 4  <-- 更新最大长度

5. 当前数: 3
   检查: 2 在集合吗? ✅ (YES) -> 跳过!

6. 当前数: 2
   检查: 1 在集合吗? ✅ (YES) -> 跳过!

最终结果: 4
```

---

## 4. Solution.py (Pythonic 代码)

**Python**

```
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        # 1. 将数组转换为集合，实现 O(1) 的查找，并去重
        num_set = set(nums)
        longest_streak = 0
      
        # 2. 遍历集合中的每个数
        for num in num_set:
            # 3. 核心剪枝：只有当 num-1 不在集合中时，num 才是一个序列的起点
            # 如果 num-1 存在，说明 num 已经被包含在以 num-1 (或更小) 开头的序列里了
            if num - 1 not in num_set:
                current_num = num
                current_streak = 1
              
                # 4. 从起点开始不断向后寻找连续的数字
                while current_num + 1 in num_set:
                    current_num += 1
                    current_streak += 1
              
                # 5. 更新最大长度
                longest_streak = max(longest_streak, current_streak)
              
        return longest_streak
```

---

## 5. 面试官视角深度剖析 (Deep Dive)

* **复杂度分析** ：
* **时间复杂度** ：**$O(n)$**。
  * 乍一看有个 `while` 循环嵌套在 `for` 循环里，感觉像 **$O(n^2)$**？
  * **其实不是** 。因为 `if num - 1 not in num_set` 这句判断，保证了每个连续序列（比如 `1,2,3,4`）只有在“龙头”（`1`）那里才会进入 `while` 循环。序列中的其他数字（`2,3,4`）会被直接跳过。
  * 所以，每个数字最多被访问两次（一次在 `for` 中，一次在 `while` 中），整体仍是线性的。
* **空间复杂度** ：**$O(n)$**。我们需要一个 Set 来存储所有数字。
* **避坑指南** ：
* **空数组处理** ：如果 `nums` 为空，代码应该返回 0。上面的代码天然支持，但有些写法（如取 `nums[0]`）会报错。
* **不要用 Sort** ：面试官强调 **$O(n)$** 就是在考察你是否会用 Hash，写了 `nums.sort()` 可能会直接挂掉。
* **重复元素** ：题目说“不要求序列元素在原数组中连续”，且可能有重复数字（如 `[1, 2, 0, 1]`）。用 `set` 天然解决了去重问题。
* **进阶追问 (Follow-up)** ：
* *问：如果内存有限，不能使用 **$O(n)$** 的空间怎么办？*
* *答* ：那就只能使用排序法了，时间换空间，时间复杂度退化为 **$O(n \log n)$**，空间为 **$O(1)$**（取决于排序算法）。
