# 一.哈希表 (Hash Table) 全方位总结

## 1. 核心概念：它到底是个啥？

### 通俗比喻：超市储物柜

想象你去超市，手里有个包（ **Value** ）。

1. 你按一下按钮，机器吐出一张条形码小票（ **Key** ）。
2. 系统内部通过一个算法（ **哈希函数** ），算出这张票对应第 3 号柜子。
3. 当你取包时，你不需要从 1 号柜挨个找，只需要把票给机器扫一下，第 3 号柜门**瞬间**弹开。

这就是哈希表的超能力：

不管柜子有多少个（数据量 N 有多大），查找目标的时间永远是 $O(1)$（瞬间找到）。

### 官方定义

哈希表是一种将 **键 (Key)** 映射到 **值 (Value)** 的数据结构。

---

## 2. 它是怎么工作的？（原理篇）

虽然我们不需要手写哈希表底层，但面试时偶尔会被问到原理。

### (1) 哈希函数 (Hash Function)

这是一个“转化器”。

* 输入：`"apple"` (Key)
* 转化：`hash("apple")` -> `9527` (一串数字)
* 映射：`9527 % 数组长度` -> **下标 5**
* 结果：把苹果存进数组的第 5 个格子里。

### (2) 哈希冲突 (Collision) —— 唯一的麻烦

问题：万一 hash("banana") 算出来也是下标 5，咋办？这也叫“撞车”。

解决：最常用的方法叫拉链法。

* 就在第 5 个格子里挂一条“链表”。
* 先把苹果挂上去，香蕉来了，就挂在苹果后面。
* *面试官潜台词：虽然理论是 **$O(1)$**，但如果冲突太多，哈希表会退化成链表，查找变成 **$O(N)$**。不过 Python 内部处理得很好，你通常不用担心。*

---

## 3. Python 中的两把武器

在 Python 里，哈希表有两种形态，请死死记住它们的区别：

### 武器一：字典 (`dict`) —— 存 Key-Value

当你需要**“查字典”**时用它。比如：存“名字 -> 电话号码”。

**Python**

```
# 初始化
phone_book = {} 

# 增
phone_book["张三"] = 10086
phone_book["李四"] = 10010

# 查 (O(1) 时间)
if "张三" in phone_book:
    print(phone_book["张三"])  # 输出 10086

# 改
phone_book["张三"] = 999

# 删
del phone_book["李四"]
```

### 武器二：集合 (`set`) —— 只存 Key

当你只需要知道**“有没有”，或者是 “去重”**时用它。它就是个**不带 Value 的字典**。

**Python**

```
# 初始化
visited = set()

# 增
visited.add(1)
visited.add(2)
visited.add(1)  # 重复添加没用，自动去重

# 查 (O(1) 时间) —— 這是 set 最强的地方！
if 2 in visited:
    print("2 存在！")

# 列表转集合（瞬间去重）
nums = [1, 2, 2, 3]
unique_nums = list(set(nums)) # [1, 2, 3]
```

---

## 4. 什么时候用哈希表？（面试“信号灯”）

只要题目里出现以下关键词，请立刻掏出哈希表：

1. **“是否存在...”**
   * 例：数组里有没有重复元素？（LC 217）
   * 解法：用 `set`。
2. **“统计频率...” / “出现了几次”**
   * 例：字符串里每个字符出现几次？
   * 解法：用 `dict` 或 `Counter`。
3. **“查找某个配对...”**
   * 例：两数之和（LC 1），找 `target - x` 在不在。
   * 解法：用 `dict` 存 `{数值: 下标}`。
4. **“去重”**
   * 例：把数组里重复的数字去掉。
   * 解法：`set(nums)`。

---

## 5. 必须掌握的高级技巧 (Pythonic)

在 Hot 100 刷题中，这两个库函数是“神器”：

### (1) `collections.Counter`

自动帮你统计频率，不用自己写循环 `if x in dic... else...`。

* **适用场景** ：字母异位词（LC 49）。

**Python**

```
from collections import Counter
s = "banana"
counts = Counter(s)
# 结果: {'a': 3, 'n': 2, 'b': 1}
```

### (2) `collections.defaultdict`

以前你需要判断 Key 是否存在，否则报错。这个东西给 Key 设置默认值。

* **适用场景** ：把单词按特征分组。

**Python**

```
from collections import defaultdict
# 默认每个 key 的 value 都是一个空列表
group = defaultdict(list) 

group["fruit"].append("apple")
group["fruit"].append("banana")
# 不需要初始化 group["fruit"] = []，直接 append！
```

---

## 6. 避坑指南（新手易错点）

1. **Key 必须是不可变的 (Immutable)**
   * ✅ 可以做 Key：整数、字符串、元组 `(1, 2)`。
   * ❌  **绝对不行** ：列表 `[1, 2]`、字典。
   * *报错* ：`TypeError: unhashable type: 'list'`
   * *原因* ：列表内容会变，内容变了哈希值就变了，柜子就找不到了。
2. **空间换时间**
   * 哈希表虽然快，但是费内存。它需要申请额外的空间来存这些 Key。面试时如果问“能不能不用额外空间？”，那就是让你放弃哈希表，改用**排序**或 **双指针** 。
3. **无序性**
   * Python 3.7+ 的字典虽然记住插入顺序，但在算法题逻辑里，请把哈希表当成**无序**的。不要指望 `set` 里的元素是排好序的。

---

## 7. Hot 100 中的哈希表“全家桶”

你已经刷了或者即将刷的这些题，核心全是哈希表：

* **Day 1: 两数之和 (Two Sum)** -> 用 `dict` 存 `{值: 下标}`，实现 **$O(1)$** 查找补数。
* **Day 2: 字母异位词分组 (Group Anagrams)** -> 用 `dict`，Key 是排序后的字符串，Value 是单词列表。
* **Day 3: 最长连续序列 (Longest Consecutive Sequence)** -> 用 `set` 去重并实现 **$O(1)$** 查找 `num-1`。
* **(未来会遇到) 和为 K 的子数组** -> 前缀和 + 哈希表。

---

### 总结一张图

| **特性**            | **数组/列表 (List)**       | **哈希表 (Dict/Set)** |
| ------------------- | -------------------------- | --------------------- |
| **查找元素 (Find)** | **$O(N)$**(慢，要遍历)     | **$O(1)$(极快)**      |
| **添加/删除**       | **$O(N)$**(慢，要移动元素) | **$O(1)$(快)**        |
| **空间占用**        | 小                         | 大 (空间换时间)       |
| **是否有序**        | 有序                       | 无序 (逻辑上)         |
| **核心用途**        | 存数据、排序               | **查找、去重、统计**  |

# 二. 哈希表：显微镜下的深度解剖

## 1. 物理结构：它本质上是个啥？

哈希表看起来很神奇，但它的“肉身”其实就是一个数组（Array）。

没错，就是那种申请一段连续内存、下标从 0 到 N-1 的数组。

* **数组的优点** ：只要知道下标 `i`，访问 `arr[i]` 是一步到位的（**$O(1)$**）。
* **哈希表的目标** ：把复杂的 `Key`（比如字符串 "apple"）变成一个整数下标 `i`。

---

## 2. 核心引擎：哈希函数 (Hash Function) 的全过程

假设我们有一个长度为 8 的空数组（哈希表初始大小通常比较小）。

我们要存入 {"apple": 5.5}。

### Step 1: 原始数据转整数 (Hash Code)

计算机只认识 0 和 1。我们需要把 "apple" 变成一个大整数。

Python 内部有一个 hash() 函数做这件事：

**Python**

```
print(hash("apple")) 
# 输出示例: 64839201 (这个数每次运行可能不一样，为了安全，但逻辑上是固定的)
```

* **原理** ：通常是利用字符的 ASCII 码进行复杂的位运算（移位、异或）。
* **要求** ：同一个输入，必须永远得到相同的输出。

### Step 2: 压缩到数组范围内 (Modulo Operation)

我们数组长度只有 8，下标只能是 0 到 7。

怎么把 64839201 塞进 0-7 里？

取模运算（求余数）：hash_value % array_length

$$
64839201 \pmod 8 = 1
$$

### Step 3: 存入 (Put)

于是，系统把 `("apple", 5.5)` 这个键值对，打包放进了数组 **下标为 1** 的格子里。

---

## 3. 致命细节：哈希冲突 (Collision)

这是面试中最爱问的细节！

场景：

现在我们要存 {"banana": 3.0}。

1. `hash("banana")` -> `992831`
2. `992831 % 8` = **1**

**出事了！** 下标 `1` 已经被 "apple" 占了！这就叫**“哈希冲突”**（撞车）。

### 解决方案 A：拉链法 (Chaining) —— 最经典、最好理解

这是很多教科书和 Java HashMap 的做法。

* 把数组的每个格子做成一个 **链表头** 。
* 下标 `1` 的格子里，本来存着 "apple"。现在 "banana" 也来了，那就把它挂在 "apple" 后面。

**ASCII 示意图：**

**Plaintext**

```
Index |  Data
-------------------------
  0   |  None
  1   |  [ "apple": 5.5 ] --> [ "banana": 3.0 ] --> None
  2   |  None
  ... |
```

* **查找时** ：算出下标 `1`，发现里面有一串。遍历这个链表，一个个比对 Key。如果是 "banana"，就取出 3.0。
* **代价** ：如果冲突太多，链表会变长，查找时间从 **$O(1)$** 退化成 **$O(N)$**。

### 解决方案 B：开放寻址法 (Open Addressing) —— Python 的做法

Python 嫌链表费内存，采用了这种更“刚”的方法。

* 下标 `1` 被占了？那我看看下标 `2` 空不空？空就占它！不空就看下标 `3`...（这叫线性探测，Python 实际用的是一种更高级的跳跃探测，防止数据扎堆）。
* **结果** ："banana" 被强行塞到了隔壁。

---

## 4. 隐形机制：扩容 (Resizing) 与 负载因子 (Load Factor)

你可能会问：*“如果一直冲突，数组塞满了怎么办？”*

哈希表有一个 **警戒线** ，叫 **负载因子 (Load Factor)** 。

* **公式** ：**$\text{已存元素个数} / \text{数组总长度}$**
* **通常阈值** ：**0.75** (即塞满 3/4)。

**扩容过程（非常消耗性能）：**

1. 当填满 75% 时，系统自动申请一个 **更大的新数组** （通常是原来的 2 倍，比如从 8 变 16）。
2. **Rehash（重新哈希）** ：注意！不能直接把旧数据搬过去。因为数组长度变了，取模的结果也变了！

* 比如 "apple" 原来是 `... % 8 = 1`。
* 现在变成 `... % 16 = 9`（假设）。

1. 系统必须把所有旧数据重新算一遍位置，搬到新家。

面试深度点：

这就是为什么我们说哈希表**“平均”**是 $O(1)$。

* 平时操作是 **$O(1)$**。
* 一旦触发扩容，那一次操作就是 **$O(N)$**。
* 但因为扩容很少发生，分摊下来还是 **$O(1)$**。

---

## 5. Python 代码里的“微操”细节

了解了原理，我们看几个你在刷题时必须知道的 **工程细节** 。

### (1) 为什么 List 不能做 Key？(Un-hashable)

**Python**

```
d = {}
my_list = [1, 2]
d[my_list] = 100  # 报错：TypeError: unhashable type: 'list'
```

 **原因** ：

* 哈希表的假设是：**Key 一旦放进去，就永远不能变。**
* 如果 List 能做 Key，你算完 `hash([1, 2])` 把它存在下标 3。
* 然后你修改列表 `my_list.append(3)`。
* 下次你再找 `hash([1, 2, 3])`，结果变了（比如变成下标 5），你就再也找不到存进去的那个值了！
* **结论** ：只有**不可变 (Immutable)** 类型能做 Key（整数、字符串、 **元组 Tuple** ）。

### (2) `popitem()` 的秘密 (Python 3.7+)

**Python**

```
d = {"a": 1, "b": 2, "c": 3}
item = d.popitem() # 移除并返回最后一个插入的项
```

在老版本 Python 和标准的哈希表理论中，哈希表是无序的。

但在 Python 3.7 以后，字典保留了插入顺序。这在某些算法题（如 LRU 缓存）中可以用作“投机取巧”的特性，但面试时建议还是把它当无序处理，除非你明确说明你知道这个特性。

### (3) 安全查找 `get`

这是新手最容易忽略的细节。

**Python**

```
counts = {"a": 1}

# 危险写法
# print(counts["b"])  # KeyError: 'b'，程序直接崩溃

# 专业写法
print(counts.get("b", 0)) # 如果 "b" 不在，返回默认值 0，程序继续运行
```

---

## 6. 总结：完整的哈希表生命周期

为了让你“不漏掉一个细节”，我们看一个数据从生到死的全过程：

1. **定义** ：`d = {}` (开辟一块小内存数组)。
2. **插入** ：`d["key"] = "val"`。

* 计算 `hash("key")`。
* `%` 数组长度得到 `index`。
* 如果 `index` 没得人，存进去。
* 如果 `index` 有人（冲突），找下一个空位（Open Addressing）或挂链表（Chaining）。
* **检查负载** ：如果太挤（>0.75），触发 **扩容** ，全员搬家。

1. **查找** ：`d["key"]`。

* 重算 `hash` 和 `index`。
* 去那个位置看，Key 是不是我们要找的？
* 如果是，返回 Value。
* 如果不是（说明之前冲突了被挤走了），继续按规则找下一个位置。

1. **删除** ：`del d["key"]`。

* 找到位置。
* **注意** ：不能直接把这个格子设为 Empty！因为这可能会打断别人的探测链条（如果 "banana" 是因为撞车才存到下一格的，把中间的删了，就找不到 "banana" 了）。
* 通常会标记为 **Dummy** (伪删除标记)，占着茅坑不拉屎，保证搜索链路不断。

# 三. 重点解释

### 1. 为什么哈希表需要“固定的 Key”？

想象你在经营一家超级快递公司（这就是哈希表）。

你的仓库巨大无比，为了快速找到包裹，你制定了一个规则：

“根据收件人的特征（Key），算出他住在几号柜子。”

#### 情况 A：收件人是“不可变”的（比如字符串、整数、元组）

* **收件人** ：张三（脸上有颗痣）。
* **规则** ：只要是“脸上有痣的张三”，包裹一律放  **101 号柜** 。
* **结果** ：张三每次来取件，你一看脸，哦，有痣！去 101 号柜拿。**哪怕过了一万年，只要他的脸没变，你都能找到他的包裹。**
* **这就是 String/Tuple：特征永远固定，所以能当 Key。**

#### 情况 B：收件人是“可变”的（比如 List）

* **收件人** ：一个穿着**红衣服**的人（这就好比 `[1, 2]`）。
* **规则** ：只要是“穿红衣服的人”，包裹放  **202 号柜** 。
* **存件** ：早上，这个人穿着红衣服来了，你把包裹放进了 202 号。
* **出事了（修改 List）** ：中午，这个人去厕所 **换了一件绿衣服** （这就好比 `list.append(3)`，内容变了）。
* **取件** ：
* 下午，他穿着**绿衣服**来取件。
* 你一看规则：不对啊，你是穿绿衣服的，按算法你应该去  **505 号柜** 。
* 他去 505 号柜一看：**空的！**
* 但他原来的包裹还在 202 号柜里锁着呢！
* **结局** ：这个包裹彻底丢了，谁也找不到了。

---

### 2. 回到计算机的世界

Python 的哈希表（字典）是通过 **Key 的内容** 来计算 **哈希值（存储地址）** 的。

**Python**

```
# 假设 Python 允许 List 做 Key（实际上不允许）

# 1. 定义一个列表（穿红衣服的人）
my_key = [1, 2] 

# 2. 算出它的哈希值是 202，把 "宝藏" 存进 202 号内存
d[my_key] = "宝藏"

# 3. 修改列表（换成绿衣服）
my_key.append(3) 
# 现在 my_key 变成了 [1, 2, 3]

# 4. 再次去取
print(d[my_key]) 
```

**这时候计算机就疯了：**

* 如果不重新算哈希值：现在的 `[1, 2, 3]` 和当初存进去的 `[1, 2]` 根本不是同一个东西，凭什么给你拿？
* 如果重新算哈希值：`[1, 2, 3]` 算出来的地址可能是  **505** ，但你的“宝藏”在 **202** 啊！你去了 505 根本找不到东西。

**为了防止这种“存进去却找不回来”的灾难发生，Python 直接制定了一条铁律：**

> 🚫 所有“会变形”的东西（List, Dict, Set），一律禁止做 Key！
>
> (这就是报错 unhashable type: 'list' 的真正意思：你这个家伙会变身，我不信任你，不给你分配柜子。)

---

### 3. 那我非要用列表里的数据做 Key 怎么办？

用 元组 (Tuple)！

元组就是**“被锁死”**的列表。一旦生成，不可修改（不能 append，不能删除）。

因为它不会变，所以 Python 信任它。

**错误的写法（会报错）：**

**Python**

```
key_list = [1, 2]
d = {}
d[key_list] = "无法运行"  # ❌ 报错！
```

**正确的写法（转成元组）：**

**Python**

```
key_list = [1, 2]
# 把它“冻结”成元组，就像给那个人拍张照片，用照片当 Key
key_tuple = tuple(key_list) # 变成了 (1, 2)

d = {}
d[key_tuple] = "成功！"     # ✅ 成功！
```

### 总结

1. **List 是“可变”的** ：像穿衣服，随时能换。如果让它当 Key，衣服一换，就找不到原来的柜子了。
2. **Tuple 是“不可变”的** ：像指纹，永远不变。所以它可以当 Key。
3. **Unhashable** = **会变的** =  **不能做 Key** 。
