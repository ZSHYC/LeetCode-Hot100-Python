
# 49. 字母异位词分组 (Group Anagrams)

## 1. 原题描述 (Problem Statement)

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

字母异位词 是指由重新排列源单词的所有字母得到的一个新单词（即：单词里包含的字母种类和数量都相同，只是顺序不同）。

**示例 1:**

> 输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
>
> 输出: [["bat"], ["nat", "tan"], ["ate", "eat", "tea"]]

**示例 2:**

> 输入: strs = [""]
>
> 输出: [[""]]

**示例 3:**

> 输入: strs = ["a"]
>
> 输出: [["a"]]

---

## 2. 标准解析 (Standard Analysis)

我们需要把“长得像”的单词归为一类。

* **暴力法 (不可行)** ：
* 拿每一个单词去和剩下的所有单词比较。
* 比较的方法是：统计两个单词的字符计数是否一致。
* **问题** ：如果数组很长，两两比较的时间复杂度会达到 **$O(N^2)$**，效率太低。
* **推荐解法：哈希表 (Hash Map)**

  * **核心痛点** ：`eat` 和 `tea` 虽然不一样，但它们“本质”是一样的（都由 1个a、1个e、1个t 组成）。
  * **思路** ：我们需要找到一个**“身份证” (Key)**，让同组的单词拥有相同的身份证，然后把它们丢进同一个哈希表的桶 (Value) 里。
  * **如何制作身份证？**
    * **方法一（排序）** ：`eat` **$\rightarrow$** `aet`，`tea` **$\rightarrow$** `aet`。只要排序后字符串一样，就是异位词。
    * **方法二（计数）** ：记录每个字母出现的次数，如 `a:1, e:1, t:1`。

  *在这里，我们采用 **排序法** ，因为逻辑最直观，且你上传的 PDF 题解中也推荐了此方法。*

---

## 3. 通俗理解与逻辑可视化 (Visual Logic)

### 💡 生活比喻：超市理货

想象你在超市整理 **乱七八糟的饮料瓶** 。

* 地上有一堆瓶子：`可乐(旧包装)`、`雪碧`、`可乐(新包装)`、`雪碧(无糖)`...
* 你的任务是把 **同一种饮料** （不管包装怎么变，成分是一样的）放进同一个箱子里。
* 怎么做？看 **成分表** ！
  * 拿起 `eat` **$\rightarrow$** 看成分：`a, e, t` **$\rightarrow$** 扔进贴着 `aet` 标签的箱子。
  * 拿起 `tea` **$\rightarrow$** 看成分：`a, e, t` **$\rightarrow$** 箱子 `aet` 已经有了，直接扔进去。
  * 拿起 `tan` **$\rightarrow$** 看成分：`a, n, t` **$\rightarrow$** 没这个箱子，拿个新箱子贴上 `ant`，扔进去。

### 📺 算法流程 ASCII 动画

假设输入：`strs = ["eat", "tea", "tan", "bat"]`

**Plaintext**

```
[ 初始化 ] 哈希表 map = {}

[ Step 1 ] 处理 "eat"
   1. 排序(eat) -> "aet" (这是它的身份证)
   2. 查表: map里有 "aet" 吗? 
      ❌ 没有 -> 创建新桶
   3. 存入: map = { 
         "aet": ["eat"] 
      }

[ Step 2 ] 处理 "tea"
   1. 排序(tea) -> "aet"
   2. 查表: map里有 "aet" 吗? 
      ✅ 有! -> "aet" 桶
   3. 存入: map = { 
         "aet": ["eat", "tea"] 
      }

[ Step 3 ] 处理 "tan"
   1. 排序(tan) -> "ant"
   2. 查表: map里有 "ant" 吗? 
      ❌ 没有 -> 创建新桶
   3. 存入: map = { 
         "aet": ["eat", "tea"],
         "ant": ["tan"] 
      }

[ Step 4 ] 处理 "bat"
   1. 排序(bat) -> "abt"
   2. 查表: ❌ -> 创建新桶
   3. 存入: map = { ..., "abt": ["bat"] }

[ 最终输出 ] -> list(map.values())
[ ["eat", "tea"], ["tan"], ["bat"] ]
```

---

## 4. Solution.py (Pythonic 代码)

**Python**

```
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        # 引入 defaultdict，它可以自动初始化不存在的 key，避免手动判断 if key in map
        from collections import defaultdict
      
        # 定义哈希表，默认的值是一个空列表 []
        anagram_map = defaultdict(list)
      
        for s in strs:
            # 1. 制作“身份证”：将字符串排序
            # 注意：sorted(s) 返回的是列表 ['a','e','t']，无法作为字典的 key
            # 所以必须用 "".join() 把它转回字符串 "aet" (或者用 tuple)
            key = "".join(sorted(s))
          
            # 2. 归类：直接把原单词 s 追加到对应的 key 列表中
            anagram_map[key].append(s)
      
        # 3. 返回所有分组（只取字典的 value 部分）
        return list(anagram_map.values())
```

---

## 5. 面试官视角深度剖析 (Deep Dive)

### 🧐 复杂度分析

* **时间复杂度** : **$O(N \cdot K \log K)$**
* **$N$** 是单词的个数。
* **$K$** 是单词的最长长度。
* 我们需要遍历 **$N$** 个单词，每个单词需要排序，排序耗时 **$O(K \log K)$**。
* **空间复杂度** : **$O(N \cdot K)$**
* 我们需要把所有单词都存进哈希表中。

### ⚠️ 避坑指南 (Common Pitfalls)

1. **Key 的类型** ：很多新手写 `map[sorted(s)] = ...` 会报错。因为 `sorted()` 返回的是 `list`（可变对象），**不能**作为字典的 Key。必须转成 `string` 或 `tuple`（不可变对象）。
2. **空字符串处理** ：题目示例给了 `[""]`，逻辑上空字符串排序后还是空，能被正确处理，不需要特判，但面试时最好口头提一下考虑到位了。

### 🗣️ 进阶追问 (Follow-up)

* **面试官问** ：如果单词非常长（**$K$** 很大），排序太慢了怎么办？
* **你回答** ：可以使用**计数法**作为 Key。不排序，而是统计 26 个字母出现的次数。
* 例如 `eat` **$\rightarrow$** Key 为 `(1, 0, 0, 0, 1, ..., 1, ...)` (元组，表示a:1, b:0..., e:1...)。
* 这样时间复杂度优化为 **$O(N \cdot K)$**，省去了 **$\log K$** 的排序开销。
